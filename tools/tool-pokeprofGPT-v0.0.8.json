[{"id":"poképrofgpt","user_id":"38dddf56-dda2-45ba-af61-b52ddf51b496","name":"PokéProfGPT","content":"\"\"\"\ntitle: PokéProfGPT Tool\ndescription: A tool for Open WebUI that integrates with the PokéAPI to provide detailed Pokémon information.\ncurrent-functions:\n    - name: get_pokemon_details\n        description: Fetches detailed information about a Pokémon, including sprites, stats, abilities, and evolution chain.\n    - name: get_ability_details\n        description: Fetches details about a specific Pokémon ability, including its effect and associated Pokémon.\n    - name: get_pokemon_location\n        description: Retrieves locations where a Pokémon can be found, organized by game version.\n    - name: get_pokemon_movelist\n        description: Fetches the movelist of a Pokémon, grouped by version group and learn method.\n    - name: get_egg_groups\n        description: Fetches details about a specific egg group, including the Pokémon that belong to it.\nauthor: q-johnson\nversion: 0.0.8\nlicense: MIT License\n\"\"\"\n\nimport requests\n\n\ndef get_pokeapi(endpoint: str):\n    url = f\"https://pokeapi.co/api/v2/{endpoint}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(\n            f\"Error fetching data from PokeAPI: [{response.status_code}] {response.text}\"\n        )\n\n\ndef format_api_param(name: str) -> str:\n    \"\"\"\n    Format parameter names for PokeAPI by replacing spaces with dashes and converting to lowercase.\n    :param name: The name to format (e.g., \"Tapu Lele\")\n    :return: Formatted name (e.g., \"tapu-lele\")\n    \"\"\"\n    return name.lower().replace(\" \", \"-\")\n\n\ndef process_evolution_chain(chain_data, evolution_list):\n    # Get the evolutions from the current chain node\n    evolves_to = chain_data.get(\"evolves_to\", [])\n\n    for evolution in evolves_to:\n        evolution_details = (\n            evolution.get(\"evolution_details\", [{}])[0]\n            if evolution.get(\"evolution_details\")\n            else {}\n        )\n\n        evolution_info = {\n            \"name\": evolution.get(\"species\", {}).get(\"name\", \"Unknown\"),\n            \"trigger\": (\n                evolution_details.get(\"trigger\", {}).get(\"name\", \"Unknown\")\n                if evolution_details\n                else \"Unknown\"\n            ),\n            \"min_level\": evolution_details.get(\"min_level\"),\n            \"item\": (\n                evolution_details.get(\"item\", {}).get(\"name\")\n                if evolution_details.get(\"item\")\n                else None\n            ),\n            \"time_of_day\": (\n                evolution_details.get(\"time_of_day\")\n                if evolution_details.get(\"time_of_day\")\n                else None\n            ),\n            \"min_happiness\": evolution_details.get(\"min_happiness\"),\n            \"held_item\": (\n                evolution_details.get(\"held_item\", {}).get(\"name\")\n                if evolution_details.get(\"held_item\")\n                else None\n            ),\n        }\n\n        # Filter out None values for cleaner output\n        evolution_info = {k: v for k, v in evolution_info.items() if v is not None}\n        evolution_list.append(evolution_info)\n\n        # Recursively process the next evolution stage\n        process_evolution_chain(evolution, evolution_list)\n\n\ndef get_pokemon_alternate_forms(pokemon_form_name: str):\n    \"\"\"\n    Fetches alternate forms of a Pokémon by its name.\n    :param pokemon_name: Name of the Pokémon (case-insensitive).\n    :return: JSON response containing alternate forms.\n    \"\"\"\n    if not isinstance(pokemon_form_name, str):\n        raise TypeError(\n            f\"Expected string for pokemon_form_name, got {type(pokemon_form_name)}\"\n        )\n\n    formatted_name = format_api_param(pokemon_form_name)\n    endpoint = f\"pokemon-form/{formatted_name}\"\n    raw_data = get_pokeapi(endpoint)\n\n    # Process and return the relevant alternate forms\n    form_data = {\n        \"name\": raw_data.get(\"name\"),\n        \"is_default\": raw_data.get(\"is_default\", False),\n        \"is_battle_only\": raw_data.get(\"is_battle_only\", False),\n        \"is_mega\": raw_data.get(\"is_mega\", False),\n        \"sprites\": {\n            \"front_default\": raw_data.get(\"sprites\", {}).get(\n                \"front_default\", \"No sprite available\"\n            ),\n            \"front_female\": raw_data.get(\"sprites\", {}).get(\n                \"front_female\", \"No sprite available\"\n            ),\n            \"front_male\": raw_data.get(\"sprites\", {}).get(\n                \"front_male\", \"No sprite available\"\n            ),\n            \"front_shiny\": raw_data.get(\"sprites\", {}).get(\n                \"front_shiny\", \"No sprite available\"\n            ),\n            \"front_shiny_female\": raw_data.get(\"sprites\", {}).get(\n                \"front_shiny_female\", \"No sprite available\"\n            ),\n            \"front_shiny_male\": raw_data.get(\"sprites\", {}).get(\n                \"front_shiny_male\", \"No sprite available\"\n            ),\n        },\n    }\n\n    # Safely handle pokemon types - the structure might vary\n    pokemon_types = []\n    types_data = raw_data.get(\"types\", [])\n    if types_data:\n        try:\n            pokemon_types = [type_info[\"type\"][\"name\"] for type_info in types_data]\n        except (TypeError, KeyError):\n            # If we can't extract types with the expected structure, try an alternate approach\n            if isinstance(types_data, list):\n                for type_info in types_data:\n                    if isinstance(type_info, dict) and \"type\" in type_info:\n                        type_data = type_info[\"type\"]\n                        if isinstance(type_data, dict) and \"name\" in type_data:\n                            pokemon_types.append(type_data[\"name\"])\n\n    form_data[\"pokemon_type\"] = pokemon_types\n\n    return form_data\n\n\nclass Tools:\n\n    def __init__(self):\n        self.citation = True\n        pass\n\n    def get_pokemon_details(self, pokemon_name: str):\n        \"\"\"\n        Fetches details of a Pokémon by its name.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: JSON response containing Pokémon details.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}\"\n        raw_data_pokemon = get_pokeapi(endpoint)\n\n        endpoint_species = f\"pokemon-species/{formatted_name}\"\n        raw_data_species = get_pokeapi(endpoint_species)\n\n        # Process and return the relevant Pokémon details\n        processed_data = {\n            \"name\": raw_data_pokemon.get(\"name\"),\n            \"id\": raw_data_pokemon.get(\"id\"),\n            \"sprite\": raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_default\", \"No sprite available\"\n            ),\n            \"sprite_male\": raw_data_pokemon.get(\"sprites\", {}).get(\"front_male\")\n            or raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_default\", \"No sprite available\"\n            ),\n            \"sprite_female\": raw_data_pokemon.get(\"sprites\", {}).get(\"front_female\")\n            or raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_default\", \"No sprite available\"\n            ),\n            \"sprite_shiny\": raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_shiny\", \"No shiny sprite available\"\n            ),\n            \"sprite_shiny_male\": raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_shiny_male\"\n            )\n            or raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_shiny\", \"No shiny sprite available\"\n            ),\n            \"sprite_shiny_female\": raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_shiny_female\"\n            )\n            or raw_data_pokemon.get(\"sprites\", {}).get(\n                \"front_shiny\", \"No shiny sprite available\"\n            ),\n            \"height\": f\"{raw_data_pokemon.get('height') / 10:.1f} meters\",\n            \"weight\": f\"{raw_data_pokemon.get('weight') / 10:.1f} kg\",\n            \"stats\": {\n                stat[\"stat\"][\"name\"]: stat[\"base_stat\"]\n                for stat in raw_data_pokemon.get(\"stats\", [])\n            },\n            \"type\": [\n                type_info[\"type\"][\"name\"]\n                for type_info in raw_data_pokemon.get(\"types\", [])\n            ],\n            \"abilities\": [\n                {\n                    \"name\": ability[\"ability\"][\"name\"],\n                    \"hidden\": ability.get(\"is_hidden\", False),\n                }\n                for ability in raw_data_pokemon.get(\"abilities\", [])\n            ],\n            \"is_legendary\": raw_data_species.get(\"is_legendary\", False),\n            \"is_mythical\": raw_data_species.get(\"is_mythical\", False),\n            \"is_baby\": raw_data_species.get(\"is_baby\", False),\n            \"flavor_text_descriptions\": {\n                entry[\"flavor_text\"]\n                for entry in raw_data_species.get(\"flavor_text_entries\", [])\n                if entry[\"language\"][\"name\"] == \"en\"\n            },\n            \"egg_groups\": [\n                egg_group[\"name\"]\n                for egg_group in raw_data_species.get(\"egg_groups\", [])\n            ],\n            \"forms\": [\n                forms[\"name\"] for forms in raw_data_pokemon.get(\"forms\", [])\n            ],  # currently not used, as the api does not provide alternate forms for all Pokémon\n        }\n\n        endpoint_evolution = f\"evolution-chain/{raw_data_species.get('evolution_chain', {}).get('url', '').split('/')[-2]}\"\n        raw_data_evolution = get_pokeapi(endpoint_evolution)\n\n        # Process evolution chain\n        processed_evolution_data = {\n            \"base_form\": raw_data_evolution.get(\"chain\", {})\n            .get(\"species\", {})\n            .get(\"name\", \"Unknown\"),\n            \"evolutions\": [],\n        }\n        process_evolution_chain(\n            raw_data_evolution.get(\"chain\", {}), processed_evolution_data[\"evolutions\"]\n        )\n\n        # Process alternate forms - data not used yet.\n        alternate_forms_data = []\n        for form_name in processed_data[\"forms\"]:\n            form_info = get_pokemon_alternate_forms(form_name)\n            alternate_forms_data.append(\n                {\n                    \"name\": form_info[\"name\"],\n                    \"is_default\": form_info[\"is_default\"],\n                    \"is_battle_only\": form_info[\"is_battle_only\"],\n                    \"is_mega\": form_info[\"is_mega\"],\n                    \"sprites\": form_info[\"sprites\"],\n                    \"pokemon_type\": form_info[\"pokemon_type\"],\n                }\n            )\n\n        # Stats Table\n        stats_header = (\n            \"| \"\n            + \" | \".join(\n                [\n                    stat_name.replace(\"-\", \" \").title()\n                    for stat_name in processed_data[\"stats\"].keys()\n                ]\n            )\n            + \" | Total |\"\n        )\n        stats_separator = \"|\" + \"---|\" * (len(processed_data[\"stats\"]) + 1)\n        stats_values = (\n            \"| \"\n            + \" | \".join(\n                [str(stat_value) for stat_value in processed_data[\"stats\"].values()]\n            )\n            + f\" | {sum(processed_data['stats'].values())} |\"\n        )\n\n        return f\"\"\"\nYou are a professor who studies Pokémon. Give an analytical description of the Pokémon {processed_data['name']}. Always include the following details:\nGeneral Information:\n| Sprite | ID | Type | Abilities | Height | Weight |\n|---|---|---|---|---|---|\n| ![{processed_data['name']} Sprite]({processed_data['sprite']}) | {processed_data['id']} | {', '.join(processed_data['type'])} | {', '.join([f\"{ability['name']} (Hidden: {ability['hidden']})\" for ability in processed_data['abilities']])} | {processed_data['height']} | {processed_data['weight']} |\n\nStats:\n{stats_header}\n{stats_separator}\n{stats_values}\n\nHistory and Pokémon Descriptions: {chr(10).join(processed_data['flavor_text_descriptions'])} *Note: History and Pokémon descriptions are often poetic and hyperbolic and may not be literal. As a professor in Pokémon studies, you should consider the broader implications of these descriptions.*\n\nInclude the evolution chain of this Pokémon. If specific evolution conditions are known, include them in the description - especially if it requires a specific item, held item, time of day, or happiness level. If the Pokémon has multiple evolutions, list them all:\n{processed_evolution_data['base_form']} evolves into {', '.join([evo['name'] for evo in processed_evolution_data['evolutions']])} based on the following conditions:\n{chr(10).join([f\"- {evo['name']} (Trigger: {evo['trigger']}, Min Level: {evo.get('min_level', 'N/A')}, Item: {evo.get('item', 'N/A')}, Time of Day: {evo.get('time_of_day', 'N/A')}, Min Happiness: {evo.get('min_happiness', 'N/A')}, Held Item: {evo.get('held_item', 'N/A')})\" for evo in processed_evolution_data['evolutions']])}\n\nInclude the additional information about the Pokémon, **only** if it is specifically requested. Otherwise do not include the additional information:\nSprite (MALE): ![{processed_data['name']} Sprite (MALE)]({processed_data['sprite_male']})\nSprite (FEMALE): ![{processed_data['name']} Sprite (FEMALE)]({processed_data['sprite_female']})\nShiny Sprite: ![{processed_data['name']} Shiny Sprite]({processed_data['sprite_shiny']})\nShiny Sprite (MALE): ![{processed_data['name']} Shiny Sprite (MALE)]({processed_data['sprite_shiny_male']})\nShiny Sprite (FEMALE): ![{processed_data['name']} Shiny Sprite (FEMALE)]({processed_data['sprite_shiny_female']})\nEgg Groups Memberships: {', '.join(processed_data['egg_groups'])} *Note: Egg groups are categories that determine which Pokémon can breed with each other. A Pokémon can belong to multiple egg groups.*\nLegendary Status: {'Yes' if processed_data['is_legendary'] else 'No'} *Note: Only a few Pokémon are classified as legendary. Do not discuss the legendary status of any Pokémon that is not classified as such.*\nMythical Status: {'Yes' if processed_data['is_mythical'] else 'No'} *Note: Mythical Pokémon are extremely rare and often event-exclusive. Do not discuss the mythical status of any Pokémon that is not classified as such.*\nBaby Status: {'Yes' if processed_data['is_baby'] else 'No'} *Note: Baby Pokémon are often pre-evolutions of other Pokémon and are typically smaller and less powerful. Do not discuss the baby status of any Pokémon that is not classified as such.*\n\"\"\"\n\n    def get_ability_details(self, ability_name: str):\n        \"\"\"\n        Fetches details of a Pokémon ability by its name.\n        :param ability_name: Name of the ability (case-insensitive).\n        :return: JSON response containing ability details.\n        \"\"\"\n        formatted_name = format_api_param(ability_name)\n        endpoint = f\"ability/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Process and return the relevant ability details\n        processed_data = {\n            \"name\": raw_data.get(\"name\"),\n            \"effect\": next(\n                (\n                    entry.get(\"effect\", \"\")\n                    for entry in raw_data.get(\"effect_entries\", [])\n                    if entry.get(\"language\", {}).get(\"name\") == \"en\"\n                ),\n                \"No effect description available in English.\",\n            ),\n            \"pokemon\": [\n                f\"{pokemon['pokemon']['name']}{' (Hidden)' if pokemon['is_hidden'] else ''}\"\n                for pokemon in raw_data.get(\"pokemon\", [])\n            ],\n        }\n        return f\"\"\"\nYou are a Pokémon expert. Describe the ability {processed_data['name']} in detail. Include the following information:\nEffect: {processed_data['effect']}\nPokémon with this ability: {', '.join(processed_data['pokemon'])}\n\"\"\"\n\n    def get_pokemon_location(self, pokemon_name: str):\n        \"\"\"\n        Fetches locations where a Pokémon can be found, organized by game version.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: JSON response containing location details sorted by game version.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}/encounters\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Group locations by game version\n        locations_by_version = {}\n\n        for encounter in raw_data:\n            location_name = encounter[\"location_area\"][\"name\"].replace(\"-\", \" \").title()\n\n            for version_detail in encounter[\"version_details\"]:\n                version_name = version_detail[\"version\"][\"name\"]\n\n                if version_name not in locations_by_version:\n                    locations_by_version[version_name] = []\n\n                if location_name not in locations_by_version[version_name]:\n                    locations_by_version[version_name].append(location_name)\n\n        # Format the output with locations organized by version\n        if not locations_by_version:\n            return f\"\"\"\nYou are a Pokémon researcher. Provide information on where the Pokémon {pokemon_name} can be found in the wild.\nUnfortunately, no location data is available for this Pokémon in the database.\n\"\"\"\n\n        # Build a formatted version-to-locations mapping for the prompt\n        formatted_locations = []\n        for version, locations in sorted(locations_by_version.items()):\n            formatted_locations.append(f\"- {version.title()}: {', '.join(locations)}\")\n\n        return f\"\"\"\nYou are a Pokémon researcher. Provide information on where the Pokémon {pokemon_name} can be found in the wild.\nThe Pokémon can be found in these locations across various games:\n\n{chr(10).join(formatted_locations)}\n\nBased on this information, describe where players might encounter this Pokémon in the wild. Do not summarize locational data. Offer all locations for every region and game.\n\"\"\"\n\n    def get_egg_groups(self, egg_group_name: str):\n        \"\"\"\n        Fetches details of an egg group by its name.\n        :param egg_group_name: Name of the egg group (case-insensitive). Possible values include \"monster\", \"water-1\", \"field\", \"ground\", etc.\n        :return: JSON response containing egg group details.\n        \"\"\"\n        formatted_name = format_api_param(egg_group_name)\n        endpoint = f\"egg-group/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Process and return the relevant egg group details\n        processed_data = {\n            \"name\": raw_data.get(\"name\"),\n            \"pokemon_in_group\": [\n                pokemon[\"name\"] for pokemon in raw_data.get(\"pokemon_species\", [])\n            ],\n        }\n\n        return f\"\"\"\nYou are a Pokémon breeding expert. Describe the egg group {processed_data['name']} in detail. Include the following information:\nEgg Group Name: {processed_data['name'].replace('-', ' ').title()}\nPokémon in this egg group:\n{', '.join(processed_data['pokemon_in_group'])}\n\n\"\"\"\n\n    def get_pokemon_movelist(self, pokemon_name: str):\n        \"\"\"\n        Fetches the movelist of a Pokémon by its name, grouped by version group.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: Formatted markdown tables of moves organized by version group.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Group moves by version_group\n        moves_by_version = {}\n\n        for move in raw_data.get(\"moves\", []):\n            move_name = move[\"move\"][\"name\"].replace(\"-\", \" \").title()\n\n            for version_detail in move[\"version_group_details\"]:\n                version_group = version_detail[\"version_group\"][\"name\"]\n                learn_method = version_detail[\"move_learn_method\"][\"name\"]\n                level_learned_at = version_detail[\"level_learned_at\"]\n\n                if version_group not in moves_by_version:\n                    moves_by_version[version_group] = []\n\n                moves_by_version[version_group].append(\n                    {\n                        \"name\": move_name,\n                        \"learn_method\": learn_method,\n                        \"level_learned_at\": level_learned_at,\n                    }\n                )\n\n        # Format the output as markdown tables by version group\n        if not moves_by_version:\n            return f\"No move data available for {pokemon_name}.\"\n\n        # Create markdown tables for each version group\n        markdown_tables = []\n        for version_group, moves in sorted(moves_by_version.items()):\n            # Sort moves: first by learn method, then by level (if applicable), then by name\n            moves.sort(\n                key=lambda x: (\n                    x[\"learn_method\"],\n                    x[\"level_learned_at\"] if x[\"level_learned_at\"] else 0,\n                    x[\"name\"],\n                )\n            )\n\n            table = f\"### {version_group.replace('-', ' ').title()}\\n\\n\"\n            table += \"| Move | Learn Method | Level |\\n\"\n            table += \"|------|-------------|-------|\\n\"\n\n            for move in moves:\n                level = (\n                    str(move[\"level_learned_at\"]) if move[\"level_learned_at\"] else \"N/A\"\n                )\n                table += f\"| {move['name']} | {move['learn_method'].replace('-', ' ').title()} | {level} |\\n\"\n\n            markdown_tables.append(table)\n\n        return f\"\"\"\nProvide information about the moves that {pokemon_name.title()} can learn across different game versions. If there is a specific game version asked about, include only the moves available in that version. If no game version is specified, provide all moves across all versions.\n{chr(10).join(markdown_tables)}\n\n\"\"\"\n\n    def get_item(self, item_name: str):\n        \"\"\"\n        Fetches details of an item by its name.\n        :param item_name: Name of the item (case-insensitive).\n        :return: JSON response containing item details.\n        \"\"\"\n        formatted_name = format_api_param(item_name)\n        endpoint = f\"item/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Process and return the relevant item details\n        processed_data = {\n            \"id\": raw_data.get(\"id\"),\n            \"name\": raw_data.get(\"name\"),\n            \"cost\": raw_data.get(\"cost\"),\n            \"fling_power\": raw_data.get(\"fling_power\"),\n            \"fling_effect\": (\n                raw_data.get(\"fling_effect\", {}).get(\"name\")\n                if raw_data.get(\"fling_effect\")\n                else None\n            ),\n            \"attributes\": [\n                attr.get(\"name\") for attr in raw_data.get(\"attributes\", []) if attr\n            ],\n            \"category\": (\n                raw_data.get(\"category\", {}).get(\"name\")\n                if raw_data.get(\"category\")\n                else None\n            ),\n            \"effect\": next(\n                (\n                    entry.get(\"effect\", \"\")\n                    for entry in raw_data.get(\"effect_entries\", [])\n                    if entry.get(\"language\", {}).get(\"name\") == \"en\"\n                ),\n                \"No effect description available in English.\",\n            ),\n            \"short_effect\": next(\n                (\n                    entry.get(\"short_effect\", \"\")\n                    for entry in raw_data.get(\"effect_entries\", [])\n                    if entry.get(\"language\", {}).get(\"name\") == \"en\"\n                ),\n                \"No short effect available in English.\",\n            ),\n            \"flavor_text\": next(\n                (\n                    entry.get(\"text\", \"\")\n                    for entry in raw_data.get(\"flavor_text_entries\", [])\n                    if entry.get(\"language\", {}).get(\"name\") == \"en\"\n                ),\n                \"No flavor text available in English.\",\n            ),\n            \"game_indices\": [\n                gi.get(\"game_index\") for gi in raw_data.get(\"game_indices\", []) if gi\n            ],\n            \"generation\": [\n                gi.get(\"generation\", {}).get(\"name\")\n                for gi in raw_data.get(\"game_indices\", [])\n                if gi.get(\"generation\")\n            ],\n            \"names\": [\n                name.get(\"name\")\n                for name in raw_data.get(\"names\", [])\n                if name.get(\"language\", {}).get(\"name\") == \"en\"\n            ],\n            \"sprites\": (\n                raw_data.get(\"sprites\", {}).get(\"default\")\n                if raw_data.get(\"sprites\")\n                else None\n            ),\n            \"held_by_pokemon\": [\n                {\n                    \"pokemon\": (\n                        held.get(\"pokemon\", {}).get(\"name\")\n                        if held.get(\"pokemon\")\n                        else None\n                    ),\n                    \"version_details\": (\n                        [\n                            {\n                                \"rarity\": vd.get(\"rarity\"),\n                                \"version\": (\n                                    vd.get(\"version\", {}).get(\"name\")\n                                    if vd.get(\"version\")\n                                    else None\n                                ),\n                            }\n                            for vd in held.get(\"version_details\", [])\n                            if vd.get(\"version\")\n                        ]\n                        if held.get(\"version_details\")\n                        else []\n                    ),\n                }\n                for held in raw_data.get(\"held_by_pokemon\", [])\n                if held\n            ],\n            \"baby_trigger_for\": (\n                raw_data.get(\"baby_trigger_for\", {}).get(\"url\")\n                if raw_data.get(\"baby_trigger_for\")\n                else None\n            ),\n        }\n        return f\"\"\"\nYou are a Pokémon item expert. Describe the item {processed_data['name']} in detail. ALWAYS include the following information:\nName: {processed_data['name'].replace('-', ' ').title()} \nSprite: ![{processed_data['name']} Sprite]({processed_data['sprites']})\nEffect: {processed_data['effect']} *Note: The effect describes what the item does when used in battles or other contexts.*\nShort Effect: {processed_data['short_effect']} *Note: The short effect is a brief summary of the item's effect.*\nFlavor Text: {processed_data['flavor_text']} *Note: The flavor text provides a description of the item as it appears in the game.*\nCost: {processed_data['cost']} *Note: The cost is the price of the item in Poké Dollars.*\nAttributes: {', '.join(processed_data['attributes']) if processed_data['attributes'] else 'None'} *Note: Attributes provide additional information about the item, such as whether it can be used in battles or is a key item.*\n\n*Note: The following information is optional and should only be included if specifically requested. Otherwise, do not include this information.*\nHeld By Pokémon: {', '.join([f\"{held['pokemon']} (Rarity: {held['version_details'][0]['rarity']}, Version: {held['version_details'][0]['version']})\" for held in processed_data['held_by_pokemon']]) if processed_data['held_by_pokemon'] else 'No Pokémon hold this item.'}\nBaby Trigger For: {processed_data['baby_trigger_for'] if processed_data['baby_trigger_for'] else 'N/A'} *Note: This indicates if the item is used to trigger the baby form of a Pokémon.*\n\"\"\"\n","specs":[{"name":"get_ability_details","description":"Fetches details of a Pokémon ability by its name.","parameters":{"properties":{"ability_name":{"description":"Name of the ability (case-insensitive).","type":"string"}},"required":["ability_name"],"type":"object"}},{"name":"get_egg_groups","description":"Fetches details of an egg group by its name.","parameters":{"properties":{"egg_group_name":{"description":"Name of the egg group (case-insensitive). Possible values include \"monster\", \"water-1\", \"field\", \"ground\", etc.","type":"string"}},"required":["egg_group_name"],"type":"object"}},{"name":"get_item","description":"Fetches details of an item by its name.","parameters":{"properties":{"item_name":{"description":"Name of the item (case-insensitive).","type":"string"}},"required":["item_name"],"type":"object"}},{"name":"get_pokemon_details","description":"Fetches details of a Pokémon by its name.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}},{"name":"get_pokemon_location","description":"Fetches locations where a Pokémon can be found, organized by game version.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}},{"name":"get_pokemon_movelist","description":"Fetches the movelist of a Pokémon by its name, grouped by version group.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}}],"meta":{"description":"A tool to look up information about Pokémon","manifest":{"title":"PokéProfGPT Tool","description":"Fetches details about a specific egg group, including the Pokémon that belong to it.","author":"q-johnson","version":"0.0.8","license":"MIT License"}},"access_control":null,"updated_at":1750207125,"created_at":1749737288}]