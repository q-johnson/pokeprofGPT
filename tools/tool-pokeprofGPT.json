[{"id":"PokéProfGPT","user_id":"38dddf56-dda2-45ba-af61-b52ddf51b496","name":"PokéProfGPT","content":"\"\"\"\ntitle: PokéProfGPT Tool\ndescription: A tool for Open WebUI that integrates with the PokéAPI to provide detailed Pokémon information.\ncurrent-functions:\n    - name: get_pokemon_details\n        description: Fetches detailed information about a Pokémon, including stats, abilities, and evolution chain.\n    - name: get_ability_details\n        description: Fetches details about a specific Pokémon ability, including its effect and associated Pokémon.\n    - name: get_pokemon_location\n        description: Retrieves locations where a Pokémon can be found, organized by game version.\n    - name: get_pokemon_movelist\n        description: Fetches the movelist of a Pokémon, grouped by version group and learn method.\nauthor: q-johnson\nversion: 0.0.7\nlicense: MIT License\n\"\"\"\n\nimport requests\n\n\ndef get_pokeapi(endpoint: str):\n    url = f\"https://pokeapi.co/api/v2/{endpoint}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise Exception(f\"Error fetching data from PokeAPI: {response.status_code}\")\n\n\ndef format_api_param(name: str) -> str:\n    \"\"\"\n    Format parameter names for PokeAPI by replacing spaces with dashes and converting to lowercase.\n    :param name: The name to format (e.g., \"Tapu Lele\")\n    :return: Formatted name (e.g., \"tapu-lele\")\n    \"\"\"\n    return name.lower().replace(\" \", \"-\")\n\n\ndef process_evolution_chain(chain_data, evolution_list):\n    # Get the evolutions from the current chain node\n    evolves_to = chain_data.get(\"evolves_to\", [])\n\n    for evolution in evolves_to:\n        evolution_details = (\n            evolution.get(\"evolution_details\", [{}])[0]\n            if evolution.get(\"evolution_details\")\n            else {}\n        )\n\n        evolution_info = {\n            \"name\": evolution.get(\"species\", {}).get(\"name\", \"Unknown\"),\n            \"trigger\": (\n                evolution_details.get(\"trigger\", {}).get(\"name\", \"Unknown\")\n                if evolution_details\n                else \"Unknown\"\n            ),\n            \"min_level\": evolution_details.get(\"min_level\"),\n            \"item\": (\n                evolution_details.get(\"item\", {}).get(\"name\")\n                if evolution_details.get(\"item\")\n                else None\n            ),\n            \"time_of_day\": (\n                evolution_details.get(\"time_of_day\")\n                if evolution_details.get(\"time_of_day\")\n                else None\n            ),\n            \"min_happiness\": evolution_details.get(\"min_happiness\"),\n            \"held_item\": (\n                evolution_details.get(\"held_item\", {}).get(\"name\")\n                if evolution_details.get(\"held_item\")\n                else None\n            ),\n        }\n\n        # Filter out None values for cleaner output\n        evolution_info = {k: v for k, v in evolution_info.items() if v is not None}\n        evolution_list.append(evolution_info)\n\n        # Recursively process the next evolution stage\n        process_evolution_chain(evolution, evolution_list)\n\n\nclass Tools:\n\n    def __init__(self):\n        self.citation = True\n        pass\n\n    def get_pokemon_details(self, pokemon_name: str):\n        \"\"\"\n        Fetches details of a Pokémon by its name.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: JSON response containing Pokémon details.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}\"\n        raw_data_pokemon = get_pokeapi(endpoint)\n\n        endpoint_species = f\"pokemon-species/{formatted_name}\"\n        raw_data_species = get_pokeapi(endpoint_species)\n\n        # Process and return the relevant Pokémon details\n        processed_data = {\n            \"name\": raw_data_pokemon.get(\"name\"),\n            \"id\": raw_data_pokemon.get(\"id\"),\n            \"height\": f\"{raw_data_pokemon.get('height') / 10:.1f} meters\",\n            \"weight\": f\"{raw_data_pokemon.get('weight') / 10:.1f} kg\",\n            \"stats\": {\n                stat[\"stat\"][\"name\"]: stat[\"base_stat\"]\n                for stat in raw_data_pokemon.get(\"stats\", [])\n            },\n            \"type\": [\n                type_info[\"type\"][\"name\"]\n                for type_info in raw_data_pokemon.get(\"types\", [])\n            ],\n            \"abilities\": [\n                ability[\"ability\"][\"name\"]\n                for ability in raw_data_pokemon.get(\"abilities\", [])\n            ],\n            \"is_legendary\": raw_data_species.get(\"is_legendary\", False),\n            \"is_mythical\": raw_data_species.get(\"is_mythical\", False),\n            \"is_baby\": raw_data_species.get(\"is_baby\", False),\n            \"flavor_text_descriptions\": {\n                entry[\"flavor_text\"]\n                for entry in raw_data_species.get(\"flavor_text_entries\", [])\n                if entry[\"language\"][\"name\"] == \"en\"\n            },\n            \"egg_groups\": [\n                egg_group[\"name\"]\n                for egg_group in raw_data_species.get(\"egg_groups\", [])\n            ],\n        }\n\n        endpoint_evolution = f\"evolution-chain/{raw_data_species.get('evolution_chain', {}).get('url', '').split('/')[-2]}\"\n        raw_data_evolution = get_pokeapi(endpoint_evolution)\n\n        # Process evolution chain\n        processed_evolution_data = {\n            \"base_form\": raw_data_evolution.get(\"chain\", {})\n            .get(\"species\", {})\n            .get(\"name\", \"Unknown\"),\n            \"evolutions\": [],\n        }\n        process_evolution_chain(\n            raw_data_evolution.get(\"chain\", {}), processed_evolution_data[\"evolutions\"]\n        )\n\n        return f\"\"\"\nYou are a professor who studies Pokémon. Give a fun description of the Pokémon {processed_data['name']}. Include the following details:\nID: {processed_data['id']}\nHeight: {processed_data['height']}\nWeight: {processed_data['weight']}\nAbilities: {', '.join(processed_data['abilities'])}\nType: {', '.join(processed_data['type'])} \nHistory and Pokémon Descriptions: {chr(10).join(processed_data['flavor_text_descriptions'])} *Note: History and Pokémon descriptions are often poetic and hyperbolic and may not be literal. As a professor in Pokémon studies, you should consider the broader implications of these descriptions.*\nBase Stat Total: {sum(processed_data['stats'].values())}\nStats: {', '.join([f\"{stat_name}: {stat_value}\" for stat_name, stat_value in processed_data['stats'].items()])}\n\nInclude the evolution chain of this Pokémon:\n{processed_evolution_data['base_form']} evolves into {', '.join([evo['name'] for evo in processed_evolution_data['evolutions']])} based on the following conditions:\n{chr(10).join([f\"- {evo['name']} (Trigger: {evo['trigger']}, Min Level: {evo.get('min_level', 'N/A')}, Item: {evo.get('item', 'N/A')}, Time of Day: {evo.get('time_of_day', 'N/A')}, Min Happiness: {evo.get('min_happiness', 'N/A')}, Held Item: {evo.get('held_item', 'N/A')})\" for evo in processed_evolution_data['evolutions']])}\n\nInclude the additional information about the Pokémon, **only** if it is relevant to the query. Otherwise do not include the additional information:\nEgg Groups: {', '.join(processed_data['egg_groups'])} *Note: Egg groups are categories that determine which Pokémon can breed with each other.*\nLegendary Status: {'Yes' if processed_data['is_legendary'] else 'No'} *Note: Only a few Pokémon are classified as legendary. Do not discuss the legendary status of any Pokémon that is not classified as such.*\nMythical Status: {'Yes' if processed_data['is_mythical'] else 'No'} *Note: Mythical Pokémon are extremely rare and often event-exclusive. Do not discuss the mythical status of any Pokémon that is not classified as such.*\nBaby Status: {'Yes' if processed_data['is_baby'] else 'No'} *Note: Baby Pokémon are often pre-evolutions of other Pokémon and are typically smaller and less powerful. Do not discuss the baby status of any Pokémon that is not classified as such.*\n\"\"\"\n\n    def get_ability_details(self, ability_name: str):\n        \"\"\"\n        Fetches details of a Pokémon ability by its name.\n        :param ability_name: Name of the ability (case-insensitive).\n        :return: JSON response containing ability details.\n        \"\"\"\n        formatted_name = format_api_param(ability_name)\n        endpoint = f\"ability/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Process and return the relevant ability details\n        processed_data = {\n            \"name\": raw_data.get(\"name\"),\n            \"effect\": next(\n                (\n                    entry.get(\"effect\", \"\")\n                    for entry in raw_data.get(\"effect_entries\", [])\n                    if entry.get(\"language\", {}).get(\"name\") == \"en\"\n                ),\n                \"No effect description available in English.\",\n            ),\n            \"pokemon\": [\n                f\"{pokemon['pokemon']['name']}{' (Hidden)' if pokemon['is_hidden'] else ''}\"\n                for pokemon in raw_data.get(\"pokemon\", [])\n            ],\n        }\n        return f\"\"\"\nYou are a Pokémon expert. Describe the ability {processed_data['name']} in detail. Include the following information:\nEffect: {processed_data['effect']}\nPokémon with this ability: {', '.join(processed_data['pokemon'])}\n\"\"\"\n\n    def get_pokemon_location(self, pokemon_name: str):\n        \"\"\"\n        Fetches locations where a Pokémon can be found, organized by game version.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: JSON response containing location details sorted by game version.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}/encounters\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Group locations by game version\n        locations_by_version = {}\n\n        for encounter in raw_data:\n            location_name = encounter[\"location_area\"][\"name\"].replace(\"-\", \" \").title()\n\n            for version_detail in encounter[\"version_details\"]:\n                version_name = version_detail[\"version\"][\"name\"]\n\n                if version_name not in locations_by_version:\n                    locations_by_version[version_name] = []\n\n                if location_name not in locations_by_version[version_name]:\n                    locations_by_version[version_name].append(location_name)\n\n        # Format the output with locations organized by version\n        if not locations_by_version:\n            return f\"\"\"\nYou are a Pokémon researcher. Provide information on where the Pokémon {pokemon_name} can be found in the wild.\nUnfortunately, no location data is available for this Pokémon in the database.\n\"\"\"\n\n        # Build a formatted version-to-locations mapping for the prompt\n        formatted_locations = []\n        for version, locations in sorted(locations_by_version.items()):\n            formatted_locations.append(f\"- {version.title()}: {', '.join(locations)}\")\n\n        return f\"\"\"\nYou are a Pokémon researcher. Provide information on where the Pokémon {pokemon_name} can be found in the wild.\nThe Pokémon can be found in these locations across various games:\n\n{chr(10).join(formatted_locations)}\n\nBased on this information, describe where players might encounter this Pokémon in the wild. Do not summarize locational data. Offer all locations for every region and game.\n\"\"\"\n\n    def get_pokemon_movelist(self, pokemon_name: str):\n        \"\"\"\n        Fetches the movelist of a Pokémon by its name, grouped by version group.\n        :param pokemon_name: Name of the Pokémon (case-insensitive).\n        :return: Formatted markdown tables of moves organized by version group.\n        \"\"\"\n        formatted_name = format_api_param(pokemon_name)\n        endpoint = f\"pokemon/{formatted_name}\"\n        raw_data = get_pokeapi(endpoint)\n\n        # Group moves by version_group\n        moves_by_version = {}\n\n        for move in raw_data.get(\"moves\", []):\n            move_name = move[\"move\"][\"name\"].replace(\"-\", \" \").title()\n\n            for version_detail in move[\"version_group_details\"]:\n                version_group = version_detail[\"version_group\"][\"name\"]\n                learn_method = version_detail[\"move_learn_method\"][\"name\"]\n                level_learned_at = version_detail[\"level_learned_at\"]\n\n                if version_group not in moves_by_version:\n                    moves_by_version[version_group] = []\n\n                moves_by_version[version_group].append(\n                    {\n                        \"name\": move_name,\n                        \"learn_method\": learn_method,\n                        \"level_learned_at\": level_learned_at,\n                    }\n                )\n\n        # Format the output as markdown tables by version group\n        if not moves_by_version:\n            return f\"No move data available for {pokemon_name}.\"\n\n        # Create markdown tables for each version group\n        markdown_tables = []\n        for version_group, moves in sorted(moves_by_version.items()):\n            # Sort moves: first by learn method, then by level (if applicable), then by name\n            moves.sort(\n                key=lambda x: (\n                    x[\"learn_method\"],\n                    x[\"level_learned_at\"] if x[\"level_learned_at\"] else 0,\n                    x[\"name\"],\n                )\n            )\n\n            table = f\"### {version_group.replace('-', ' ').title()}\\n\\n\"\n            table += \"| Move | Learn Method | Level |\\n\"\n            table += \"|------|-------------|-------|\\n\"\n\n            for move in moves:\n                level = (\n                    str(move[\"level_learned_at\"]) if move[\"level_learned_at\"] else \"N/A\"\n                )\n                table += f\"| {move['name']} | {move['learn_method'].replace('-', ' ').title()} | {level} |\\n\"\n\n            markdown_tables.append(table)\n\n        return f\"\"\"\nProvide information about the moves that {pokemon_name.title()} can learn across different game versions. If there is a specific game version asked about, include only the moves available in that version. If no game version is specified, provide all moves across all versions.\n{chr(10).join(markdown_tables)}\n\n\"\"\"\n","specs":[{"name":"get_ability_details","description":"Fetches details of a Pokémon ability by its name.","parameters":{"properties":{"ability_name":{"description":"Name of the ability (case-insensitive).","type":"string"}},"required":["ability_name"],"type":"object"}},{"name":"get_pokemon_details","description":"Fetches details of a Pokémon by its name.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}},{"name":"get_pokemon_location","description":"Fetches locations where a Pokémon can be found, organized by game version.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}},{"name":"get_pokemon_movelist","description":"Fetches the movelist of a Pokémon by its name, grouped by version group.","parameters":{"properties":{"pokemon_name":{"description":"Name of the Pokémon (case-insensitive).","type":"string"}},"required":["pokemon_name"],"type":"object"}}],"meta":{"description":"A tool to look up information about Pokémon","manifest":{"title":"PokéProfGPT Tool","description":"Fetches the movelist of a Pokémon, grouped by version group and learn method.","author":"q-johnson","version":"0.0.7","license":"MIT License"}},"access_control":null,"updated_at":1749737091,"created_at":1749673271}]